# Мотивация выбора баз данных и механик коммуникаций
1: Использование реляционной СУБД для структурированных медицинских данных
•	Статус: принято 
•	Контекст: система должна хранить и обрабатывать сложные структурированные данные: демографию пациентов, метаданные исследований (дата, тип снимка, врач), аннотации, результаты работы ML-моделей (координаты позвонков, углы, классификации), историю прогнозов. Необходимы гарантии целостности, консистентности и сложные связи между сущностями.
•	Варианты:
1.	Реляционная СУБД (PostgreSQL, MySQL).
2.	Документоориентированная NoSQL БД (MongoDB).
3.	Графовая БД (Neo4j).
•	Выбор: PostgreSQL.
•	Обоснование:
1.	Целостность данных (ACID): критически важна для медицинской информации. Нельзя потерять или повредить связь "пациент-исследование-результат".
2.	Сложные запросы: для аналитики и отчетов требуются JOIN'ы по нескольким таблицам (пациенты ↔ исследования ↔ диагнозы).
3.	JSONB PostgreSQL: позволяет гибко хранить полуструктурированные данные (например, JSON с результатами детекции ML-модели) в рамках строгой схемы, сочетая лучшее из обоих миров.
4.	Зрелость и экосистема: надежность, проверенная временем, и богатый инструментарий.
•	Последствия:
1.	Положительные: гарантированная консистентность, мощный язык запросов SQL, поддержка транзакций.
2.	Отрицательные: сложнее горизонтально масштабироваться на запись. Требует тщательного проектирования схемы на старте (миграции возможны, но затратны).
2: Использование объектного хранилища для медицинских изображений
•	Статус: принято
•	Контекст: рентген-снимки, КТ и МРТ серии — это большие бинарные объекты (от единиц МБ до ГБ). Хранение их в поле BLOB реляционной БД резко снижает ее производительность и усложняет управление.
•	Варианты:
1.	Поле BLOB в PostgreSQL.
2.	Файловая система сервера.
3.	Объектное хранилище (MinIO, AWS S3, совместимые аналоги).
•	Выбор: S3-совместимое объектное хранилище (MinIO для on-premise развертывания).
•	Обоснование:
1.	Масштабируемость: специально разработано для хранения и отдачи огромных объемов бинарных данных.
2.	Экономичность: стоимость хранения ниже, чем в высокопроизводительной СУБД.
3.	Доступность и надежность: встроенные механизмы репликации и отказоустойчивости.
4.	Метаданные: возможность хранить ключевую информацию (ID исследования) вместе с объектом.
5.	Стандарт де-факто: S3 API стал промышленным стандартом для работы с объектами.
•	Последствия:
1.	Положительные: высокая производительность при загрузке/скачивании, простое масштабирование, отделение "статики" от "логики".
2.	Отрицательные: усложнение архитектуры (два источника данных). Необходимо обеспечивать консистентность ссылок: если файл удален из хранилища, ссылка в PostgreSQL должна стать невалидной.
3: Использование Redis для кеширования и асинхронных задач
•	Статус: принято
•	Контекст: частые запросы к БД (например, списки пациентов, история исследований) создают избыточную нагрузку. Обработка снимков ML-моделями — длительная операция, которую нельзя выполнять в контексте HTTP-запроса.
•	Варианты:
1.	In-memory кеш (Redis, Memcached).
2.	Кеширование на уровне БД (материализованные представления).
3.	Фоновые задачи через Cron/Worker Threads без брокера.
•	Выбор: Redis в роли кеша и брокера сообщений для фоновых задач (через Celery или RSMQ).
•	Обоснование:
1.	Производительность: данные в оперативной памяти обеспечивают скорость отклика в микросекундах.
2.	Универсальность: Redis поддерживает не только ключ-значение, но и структуры данных для очередей (Lists, Pub/Sub, Streams), что делает его простым и эффективным брокером.
3.	Распространенность: является стандартным решением для подобных задач в стеке Python/JS.
•	Последствия:
1.	Положительные: резкое ускорение отклика API, снижение нагрузки на PostgreSQL, возможность асинхронной обработки.
2.	Отрицательные: вводит дополнительный компонент, требующий мониторинга. Данные в кеше могут устаревать (необходима стратегия инвалидации). Задачи в очереди могут быть потеряны при падении Redis (требуется настройка персистентности).
4: Выбор REST API как основного протокола клиент-серверного взаимодействия
•	Статус: принято
•	Контекст: веб-клиенту (интерфейсу врача) необходимо управлять сущностями (CRUD), получать списки, загружать метаданные. Нужен простой, предсказуемый и широко поддерживаемый протокол.
•	Варианты:
1.	REST API.
2.	GraphQL.
3.	gRPC-Web.
•	Выбор: REST API over HTTPS.
•	Обоснование:
1.	Простота и понятность: легко разрабатывать, тестировать (через Postman, Swagger), отлаживать.
2.	Идемпотентность и кешируемость: стандартные HTTP-методы и коды состояния идеально подходят для операций с ресурсами. Легко кешировать на уровне CDN или прокси.
3.	Экосистема: огромное количество готовых библиотек, инструментов для документации (OpenAPI), клиентов на всех языках.
4.	Зрелость: предсказуемое поведение, низкий порог вхождения для новых разработчиков.
•	Последствия:
1.	Положительные: быстрая разработка, отличная поддерживаемость, гибкость на стороне клиента (может запрашивать только нужные данные по разным endpoint'ам).
2.	Отрицательные: риск over-fetching (клиент получает лишние данные) или under-fetching (требуется несколько запросов). Менее строгий контракт по сравнению с gRPC.
5: Использование WebSocket для интерактивной работы с 3D-симулятором
•	Статус: принято
•	Контекст: при изменении параметров прогноза (например, "смоделировать развитие сколиоза через 3 года") требуется мгновенно перестраивать и отображать новую 3D-модель без перезагрузки страницы. Нужен двусторонний канал связи с низкой задержкой.
•	Варианты:
1.	Polling (периодические HTTP-запросы).
2.	Long Polling / Server-Sent Events (SSE).
3.	WebSocket.
•	Выбор: WebSocket (WSS).
•	Обоснование:
1.	Низкая задержка и полнодуплексность: после установки соединения данные можно передавать в обе стороны мгновенно и с минимальными накладными расходами.
2.	Интерактивность: идеально для сценариев "живого" обновления сложной визуализации в ответ на действия пользователя.
3.	Нативная поддержка браузерами: не требует плагинов, работает с JavaScript.
•	Последствия:
1.	Положительные: высокая отзывчивость интерфейса, реалистичная "симуляция".
2.	Отрицательные: усложняет серверную архитектуру (необходимо управлять множеством постоянных соединений, их состоянием). Требует механизмов переподключения при обрыве сети.
6: Внедрение Message Broker (RabbitMQ) для межсервисной асинхронной коммуникации
•	Статус: принято
•	Контекст: обработка изображений нейросетями и построение 3D-моделей — ресурсоемкие операции, длящиеся секунды или минуты. Их выполнение в потоке HTTP-запроса неприемлемо (таймауты, блокировка пользователя). Нужна надежная асинхронная модель.
•	Варианты:
1.	Самостоятельная реализация очереди на Redis.
2.	Использование облачных managed-очередей (Amazon SQS, Google Pub/Sub).
3.	Использование полноценного брокера сообщений (RabbitMQ, Apache Kafka).
•	Выбор: RabbitMQ.
•	Обоснование:
1.	Надежность: гарантированная доставка сообщений (ACK механизм), persistence, высокая доступность.
2.	Гибкость маршрутизации: мощная модель exchange-queue-binding позволяет гибко распределять задачи между разными воркерами.
3.	Простота и достаточность: для данного проекта не требуются экстремальная пропускная способность или долговременное хранение логов, где силен Kafka. RabbitMQ проще в освоении и администрировании для классических фоновых задач.
•	Последствия:
1.	Положительные: высокая отказоустойчивость, развязка сервисов, возможность масштабирования обработчиков.
2.	Отрицательные: добавление нового сложного инфраструктурного компонента, требующего мониторинга и резервирования.
7: Использование gRPC для коммуникации с ML-сервисами
•	Статус: принято
•	Контекст: ML-сервисы (сегментация, классификация) принимают на вход большие массивы данных (препроцессированные изображения, тензоры) и возвращают структурированные результаты. Нужен высокопроизводительный, строго типизированный протокол.
•	Варианты:
1.	REST с JSON.
2.	REST с бинарными данными (multipart/form-data).
3.	gRPC.
•	Выбор: gRPC.
•	Обоснование:
1.	Производительность: бинарный формат Protobuf в разы компактнее и быстрее в сериализации/десериализации, чем JSON.
2.	Строгая типизация: контракты (.proto файлы) исключают ошибки несоответствия типов данных на клиенте и сервере, служат документацией.
3.	Потоковая передача: поддержка server/client/duplex streaming может быть полезна для передачи серий снимков или стриминга промежуточных результатов.
4.	Экосистема для ML: широко используется в ML-инфраструктуре (например, в TensorFlow Serving).
•	Последствия:
1.	Положительные: максимальная эффективность межсервисного взаимодействия, надежность за счет контрактов.
2.	Отрицательные: сложнее в отладке (требуются специальные инструменты, например, BloomRPC). Не работает "из коробки" в браузере (для клиент-ML коммуникации не подходит, только сервер-ML).
8: Выбор Three.js для 3D-визуализации на стороне клиента
•	Статус: принято
•	Контекст: требуется отображать детализированную, интерактивную 3D-модель позвоночника в веб-браузере. Модель должна позволять вращение, зум, выделение сегментов, изменение визуализации (например, цвет по степени патологии).
•	Варианты:
1.	Canvas 2D API.
2.	Низкоуровневое использование WebGL.
3.	Высокоуровневые библиотеки (Three.js, Babylon.js, PlayCanvas).
•	Выбор: Three.js.
•	Обоснование:
1.	Абстракция над WebGL: позволяет работать с понятиями "сцена", "камера", "меш", "материал", "источник света", не вдаваясь в сложности шейдеров и буферов.
2.	Популярность и комьюнити: крупнейшее сообщество, огромное количество примеров, плагинов и готовых решений, что ускоряет разработку.
3.	Функциональность: из коробки предоставляет загрузчики для форматов 3D-моделей (включая glTF), продвинутые материалы, эффекты, систему анимации.
•	Последствия:
1.	Положительные: относительно быстрая разработка сложной 3D-сцены, доступ к богатой экосистеме.
2.	Отрицательные: размер бандла библиотеки. Для сверхспецифичных оптимизаций может потребоваться "спуск" на уровень WebGL.
9: Использование формата glTF для 3D-моделей
•	Статус: принято
•	Контекст: серверный 3D-генератор создает геометрию позвоночника. Эту геометрию необходимо эффективно передать по сети и загрузить в Three.js на клиенте.
•	Варианты:
1.	Собственный бинарный/JSON формат.
2.	Классические форматы (OBJ, STL, FBX).
3.	Современный веб-формат (glTF/GLB).
•	Выбор: glTF 2.0, предпочтительно в бинарной упаковке (.glb).
•	Обоснование:
1.	"JPEG для 3D": специально создан для передачи и быстрой загрузки 3D-сцен в веб и мобильные приложения.
2.	Эффективность: все ресурсы (геометрия, текстуры, анимации) упакованы в один компактный файл, что минимизирует количество HTTP-запросов.
3.	Нативная поддержка Three.js: загрузчик GLTFLoader является стандартным и хорошо оптимизированным.
4.	Стандарт Khronos Group: открытый, бесплатный стандарт, поддерживаемый всеми крупными игроками в области 3D.
•	Последствия:
1.	Положительные: быстрая загрузка, простой конвейер "сервер → клиент".
2.	Отрицательные: требует, чтобы серверный 3D-генератор поддерживал экспорт в glTF. Менее универсален для оффлайн-редактирования, чем FBX.
10: Принятие модульной/микросервисной архитектуры
•	Статус: принято
•	Контекст: система состоит из логически независимых компонентов с разными требованиями: веб-API (высокая доступность, работа с пользователем), ML-инференс (тяжелые вычисления на GPU), 3D-генерация (специфичные алгоритмы). Их жизненные циклы, масштабирование и технологии могут отличаться.
•	Варианты:
1.	Монолитное приложение.
2.	Микросервисная архитектура.
3.	Модульный монолит с четкими границами (Modular Monolith).
•	Выбор: гибридный подход: модульный монолит для ядра (Web API + Бизнес-логика) + выделенные микросервисы для специфичных задач (ML Service, 3D Generator). Взаимодействие через API и RabbitMQ.
•	Обоснование:
1.	Разделение ответственности: ML-сервис можно разрабатывать на Python (PyTorch/TensorFlow), независимо от основного бэкенда (например, на Go или Java).
2.	Независимое масштабирование: при росте нагрузки можно добавить больше реплик ML-сервиса, не трогая веб-сервер.
3.	Отказоустойчивость: падение 3D-генератора не должно "валить" весь процесс загрузки снимка.
4.	Практичность: полный микросервис для маленькой команды может быть избыточен. Модульный монолит проще на старте, но позволяет позже отщепить сервисы.
•	Последствия:
1.	Положительные: гибкость, технологическая свобода, устойчивость к сбоям, возможность параллельной разработки.
2.	Отрицательные: значительное усложнение операционной работы (оркестрация контейнеров Docker, service discovery, централизованное логирование, мониторинг трассировки запросов). Увеличивает задержки из-за сетевого взаимодействия.
