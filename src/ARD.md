# Мотивация выбора баз данных и механик коммуникаций
**1: Использование реляционной СУБД для структурированных медицинских данных**
<div style = "text-align: justify">
 <p><strong>Статус:</strong> принято</p>
  <p><strong>Контекст:</strong> Система должна хранить и обрабатывать сложные структурированные данные: демографию пациентов, метаданные исследований, аннотации, результаты работы ML-моделей, историю прогнозов. Необходимы гарантии целостности, консистентности и сложные связи между сущностями.</p>
  <p><strong>Варианты:</strong></p>
  <ul>
    <li>Реляционная СУБД (PostgreSQL, MySQL)</li>
    <li>Документоориентированная NoSQL БД (MongoDB)</li>
    <li>Графовая БД (Neo4j)</li>
  </ul>
  <p><strong>Выбор:</strong> PostgreSQL</p>
  <p><strong>Обоснование:</strong></p>
  <ul>
    <li>Целостность данных (ACID): критически важна для медицинской информации</li>
    <li>Сложные запросы: требуются JOIN'ы по нескольким таблицам для аналитики</li>
    <li>JSONB PostgreSQL: гибкое хранение полуструктурированных данных в рамках строгой схемы</li>
    <li>Зрелость и экосистема: надежность и богатый инструментарий</li>
  </ul>
  <p><strong>Последствия:</strong></p>
  <ul>
    <li><strong>Положительные:</strong> гарантированная консистентность, мощный SQL, поддержка транзакций</li>
    <li><strong>Отрицательные:</strong> сложнее горизонтально масштабироваться, требует тщательного проектирования схемы</li>
  </ul>
</div>

**2: Использование объектного хранилища для медицинских изображений**
<div style = "text-align: justify">
    <p><strong>Статус:</strong> принято</p>
  <p><strong>Контекст:</strong> Рентген-снимки, КТ и МРТ серии — это большие бинарные объекты (от единиц МБ до ГБ). Хранение их в поле BLOB реляционной БД резко снижает производительность и усложняет управление.</p>
  <p><strong>Варианты:</strong></p>
  <ul>
    <li>Поле BLOB в PostgreSQL</li>
    <li>Файловая система сервера</li>
    <li>Объектное хранилище (MinIO, AWS S3, совместимые аналоги)</li>
  </ul>
  <p><strong>Выбор:</strong> S3-совместимое объектное хранилище (MinIO для on-premise развертывания)</p>
  <p><strong>Обоснование:</strong></p>
  <ul>
    <li>Масштабируемость: разработано для хранения огромных объемов бинарных данных</li>
    <li>Экономичность: стоимость хранения ниже, чем в высокопроизводительной СУБД</li>
    <li>Доступность и надежность: встроенные механизмы репликации и отказоустойчивости</li>
    <li>Метаданные: возможность хранить ключевую информацию вместе с объектом</li>
    <li>Стандарт де-факто: S3 API — промышленный стандарт</li>
  </ul>
  <p><strong>Последствия:</strong></p>
  <ul>
    <li><strong>Положительные:</strong> высокая производительность, простое масштабирование, отделение "статики" от "логики"</li>
    <li><strong>Отрицательные:</strong> усложнение архитектуры, необходимость обеспечения консистентности ссылок</li>
  </ul>
</div>

**3: Использование Redis для кеширования и асинхронных задач**
<div style = "text-align: justify">
<p><strong>Статус:</strong> принято</p>
<p><strong>Контекст:</strong> Частые запросы к БД создают избыточную нагрузку. Обработка снимков ML-моделями — длительная операция, которую нельзя выполнять в контексте HTTP-запроса.</p>
<p><strong>Варианты:</strong></p>
<ul>
  <li>In-memory кеш (Redis, Memcached)</li>
  <li>Кеширование на уровне БД (материализованные представления)</li>
  <li>Фоновые задачи через Cron/Worker Threads без брокера</li>
</ul>
<p><strong>Выбор:</strong> Redis в роли кеша и брокера сообщений для фоновых задач (через Celery или RSMQ)</p>
<p><strong>Обоснование:</strong></p>
<ul>
  <li>Производительность: данные в оперативной памяти обеспечивают скорость отклика в микросекундах</li>
  <li>Универсальность: поддерживает структуры данных для очередей (Lists, Pub/Sub, Streams)</li>
  <li>Распространенность: стандартное решение для подобных задач в стеке Python/JS</li>
</ul>
<p><strong>Последствия:</strong></p>
<ul>
  <li><strong>Положительные:</strong> ускорение отклика API, снижение нагрузки на PostgreSQL, возможность асинхронной обработки</li>
  <li><strong>Отрицательные:</strong> дополнительный компонент, требующий мониторинга; данные в кеше могут устаревать; задачи могут быть потеряны при падении Redis</li>
</ul>
</div>

**4: Выбор REST API как основного протокола клиент-серверного взаимодействия**
<div style = "text-align: justify">
<p><strong>Статус:</strong> принято</p>
<p><strong>Контекст:</strong> Веб-клиенту необходимо управлять сущностями (CRUD), получать списки, загружать метаданные. Нужен простой, предсказуемый и широко поддерживаемый протокол.</p>
<p><strong>Варианты:</strong></p>
<ul>
  <li>REST API</li>
  <li>GraphQL</li>
  <li>gRPC-Web</li>
</ul>
<p><strong>Выбор:</strong> REST API over HTTPS</p>
<p><strong>Обоснование:</strong></p>
<ul>
  <li>Простота и понятность: легко разрабатывать, тестировать, отлаживать</li>
  <li>Идемпотентность и кешируемость: стандартные HTTP-методы идеально подходят для операций с ресурсами</li>
  <li>Экосистема: огромное количество готовых библиотек, инструментов для документации</li>
  <li>Зрелость: предсказуемое поведение, низкий порог вхождения</li>
</ul>
<p><strong>Последствия:</strong></p>
<ul>
  <li><strong>Положительные:</strong> быстрая разработка, отличная поддерживаемость, гибкость на стороне клиента</li>
  <li><strong>Отрицательные:</strong> риск over-fetching или under-fetching; менее строгий контракт по сравнению с gRPC</li>
</ul>
</div>

**5: Использование WebSocket для интерактивной работы с 3D-симулятором**
<div style = "text-align: justify">
<p><strong>Статус:</strong> принято</p>
<p><strong>Контекст:</strong> При изменении параметров прогноза требуется мгновенно перестраивать и отображать новую 3D-модель без перезагрузки страницы. Нужен двусторонний канал связи с низкой задержкой.</p>
<p><strong>Варианты:</strong></p>
<ul>
  <li>Polling (периодические HTTP-запросы)</li>
  <li>Long Polling / Server-Sent Events (SSE)</li>
  <li>WebSocket</li>
</ul>
<p><strong>Выбор:</strong> WebSocket (WSS)</p>
<p><strong>Обоснование:</strong></p>
<ul>
  <li>Низкая задержка и полнодуплексность: данные можно передавать в обе стороны мгновенно</li>
  <li>Интерактивность: идеально для "живого" обновления сложной визуализации</li>
  <li>Нативная поддержка браузерами: не требует плагинов, работает с JavaScript</li>
</ul>
<p><strong>Последствия:</strong></p>
<ul>
  <li><strong>Положительные:</strong> высокая отзывчивость интерфейса, реалистичная "симуляция"</li>
  <li><strong>Отрицательные:</strong> усложняет серверную архитектуру, требует управления постоянными соединениями и механизмов переподключения</li>
</ul>
</div>

**6: Внедрение Message Broker (RabbitMQ) для межсервисной асинхронной коммуникации**
<div style = "text-align: justify">
<p><strong>Статус:</strong> принято</p>
<p><strong>Контекст:</strong> Обработка изображений нейросетями и построение 3D-моделей — ресурсоемкие операции, длящиеся секунды или минуты. Их выполнение в потоке HTTP-запроса неприемлемо (таймауты, блокировка пользователя). Нужна надежная асинхронная модель.</p>
<p><strong>Варианты:</strong></p>
<ul>
  <li>Самостоятельная реализация очереди на Redis</li>
  <li>Использование облачных managed-очередей (Amazon SQS, Google Pub/Sub)</li>
  <li>Использование полноценного брокера сообщений (RabbitMQ, Apache Kafka)</li>
</ul>
<p><strong>Выбор:</strong> RabbitMQ</p>
<p><strong>Обоснование:</strong></p>
<ul>
  <li>Надежность: гарантированная доставка сообщений (ACK механизм), persistence, высокая доступность</li>
  <li>Гибкость маршрутизации: мощная модель exchange-queue-binding для распределения задач</li>
  <li>Простота и достаточность: проще в освоении и администрировании для классических фоновых задач</li>
</ul>
<p><strong>Последствия:</strong></p>
<ul>
  <li><strong>Положительные:</strong> высокая отказоустойчивость, развязка сервисов, возможность масштабирования обработчиков</li>
  <li><strong>Отрицательные:</strong> добавление сложного инфраструктурного компонента, требующего мониторинга и резервирования</li>
</ul>
</div>

**7: Использование gRPC для коммуникации с ML-сервисами**
<div style = "text-align: justify">
<p><strong>Статус:</strong> принято</p>
<p><strong>Контекст:</strong> ML-сервисы принимают на вход большие массивы данных (препроцессированные изображения, тензоры) и возвращают структурированные результаты. Нужен высокопроизводительный, строго типизированный протокол.</p>
<p><strong>Варианты:</strong></p>
<ul>
  <li>REST с JSON</li>
  <li>REST с бинарными данными (multipart/form-data)</li>
  <li>gRPC</li>
</ul>
<p><strong>Выбор:</strong> gRPC</p>
<p><strong>Обоснование:</strong></p>
<ul>
  <li>Производительность: бинарный формат Protobuf компактнее и быстрее JSON</li>
  <li>Строгая типизация: контракты исключают ошибки несоответствия типов</li>
  <li>Потоковая передача: поддержка streaming для передачи серий снимков</li>
  <li>Экосистема для ML: широко используется в ML-инфраструктуре</li>
</ul>
<p><strong>Последствия:</strong></p>
<ul>
  <li><strong>Положительные:</strong> максимальная эффективность, надежность за счет контрактов</li>
  <li><strong>Отрицательные:</strong> сложнее в отладке, не работает в браузере напрямую</li>
</ul>
</div>

**8: Выбор Three.js для 3D-визуализации на стороне клиента**
<div style = "text-align: justify">
<p><strong>Статус:</strong> принято</p>
<p><strong>Контекст:</strong> Требуется отображать детализированную, интерактивную 3D-модель позвоночника в веб-браузере с возможностью вращения, зума, выделения сегментов.</p>
<p><strong>Варианты:</strong></p>
<ul>
  <li>Canvas 2D API</li>
  <li>Низкоуровневое использование WebGL</li>
  <li>Высокоуровневые библиотеки (Three.js, Babylon.js, PlayCanvas)</li>
</ul>
<p><strong>Выбор:</strong> Three.js</p>
<p><strong>Обоснование:</strong></p>
<ul>
  <li>Абстракция над WebGL: работа с понятиями "сцена", "камера", "меш" без сложностей шейдеров</li>
  <li>Популярность и комьюнити: крупнейшее сообщество, множество примеров и плагинов</li>
  <li>Функциональность: загрузчики для форматов 3D-моделей, материалы, эффекты, анимация</li>
</ul>
<p><strong>Последствия:</strong></p>
<ul>
  <li><strong>Положительные:</strong> относительно быстрая разработка сложной 3D-сцены, доступ к богатой экосистеме</li>
  <li><strong>Отрицательные:</strong> размер бандла библиотеки, для специфичных оптимизаций может потребоваться работа на уровне WebGL</li>
</ul>
</div>

**9: Использование формата glTF для 3D-моделей**
<div style = "text-align: justify">
<p><strong>Статус:</strong> принято</p>
<p><strong>Контекст:</strong> Серверный 3D-генератор создает геометрию позвоночника. Эту геометрию необходимо эффективно передать по сети и загрузить в Three.js на клиенте.</p>
<p><strong>Варианты:</strong></p>
<ul>
  <li>Собственный бинарный/JSON формат</li>
  <li>Классические форматы (OBJ, STL, FBX)</li>
  <li>Современный веб-формат (glTF/GLB)</li>
</ul>
<p><strong>Выбор:</strong> glTF 2.0, предпочтительно в бинарной упаковке (.glb)</p>
<p><strong>Обоснование:</strong></p>
<ul>
  <li>"JPEG для 3D": специально создан для передачи и быстрой загрузки 3D-сцен в веб</li>
  <li>Эффективность: все ресурсы упакованы в один компактный файл, минимизация HTTP-запросов</li>
  <li>Нативная поддержка Three.js: стандартный и оптимизированный загрузчик GLTFLoader</li>
  <li>Стандарт Khronos Group: открытый стандарт, поддерживаемый крупными игроками в области 3D</li>
</ul>
<p><strong>Последствия:</strong></p>
<ul>
  <li><strong>Положительные:</strong> быстрая загрузка, простой конвейер "сервер → клиент"</li>
  <li><strong>Отрицательные:</strong> требует поддержки экспорта в glTF на сервере, менее универсален для оффлайн-редактирования</li>
</ul>
</div>

**10: Принятие модульной/микросервисной архитектуры**
<div style = "text-align: justify">
<p><strong>Статус:</strong> принято</p>
<p><strong>Контекст:</strong> Система состоит из логически независимых компонентов с разными требованиями: веб-API, ML-инференс, 3D-генерация. Их жизненные циклы, масштабирование и технологии могут отличаться.</p>
<p><strong>Варианты:</strong></p>
<ul>
  <li>Монолитное приложение</li>
  <li>Микросервисная архитектура</li>
  <li>Модульный монолит с четкими границами (Modular Monolith)</li>
</ul>
<p><strong>Выбор:</strong> Гибридный подход: модульный монолит для ядра + выделенные микросервисы для специфичных задач (ML Service, 3D Generator)</p>
<p><strong>Обоснование:</strong></p>
<ul>
  <li>Разделение ответственности: независимая разработка ML-сервиса на Python</li>
  <li>Независимое масштабирование: добавление реплик ML-сервиса без изменения веб-сервера</li>
  <li>Отказоустойчивость: падение 3D-генератора не влияет на основной процесс</li>
  <li>Практичность: модульный монолит проще на старте, но позволяет позже отщепить сервисы</li>
</ul>
<p><strong>Последствия:</strong></p>
<ul>
  <li><strong>Положительные:</strong> гибкость, технологическая свобода, устойчивость к сбоям, параллельная разработка</li>
  <li><strong>Отрицательные:</strong> усложнение операционной работы, увеличение задержек из-за сетевого взаимодействия</li>
</ul>
</div>